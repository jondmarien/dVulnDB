const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("VulnerabilityRegistry", function () {
  let vulnerabilityRegistry;
  let bountyEscrow;
  let reputationNFT;
  let owner;
  let researcher;
  let validator1;
  let validator2;
  let researcher2;

  beforeEach(async function () {
    [owner, researcher, validator1, validator2, researcher2] = await ethers.getSigners();

    // Deploy contracts
    const BountyEscrow = await ethers.getContractFactory("BountyEscrow");
    bountyEscrow = await BountyEscrow.deploy();

    const ReputationNFT = await ethers.getContractFactory("ReputationNFT");
    reputationNFT = await ReputationNFT.deploy();

    const VulnerabilityRegistry = await ethers.getContractFactory("VulnerabilityRegistry");
    vulnerabilityRegistry = await VulnerabilityRegistry.deploy();

    // Setup contract connections
    await bountyEscrow.setVulnerabilityRegistry(vulnerabilityRegistry.address);
    await vulnerabilityRegistry.setBountyEscrow(bountyEscrow.address);
    await reputationNFT.setVulnerabilityRegistry(vulnerabilityRegistry.address);

    // Add validators
    await vulnerabilityRegistry.addValidator(validator1.address);
    await vulnerabilityRegistry.addValidator(validator2.address);
    await bountyEscrow.addApprover(validator1.address);
    await bountyEscrow.addApprover(validator2.address);
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await vulnerabilityRegistry.owner()).to.equal(owner.address);
    });

    it("Should have owner as default validator", async function () {
      expect(await vulnerabilityRegistry.isValidator(owner.address)).to.be.true;
    });

    it("Should have correct initial state", async function () {
      expect(await vulnerabilityRegistry.getTotalVulnerabilities()).to.equal(0);
    });
  });

  describe("Vulnerability Submission", function () {
    it("Should submit vulnerability successfully", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml", "nikto-results.txt"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await expect(
        vulnerabilityRegistry
          .connect(researcher)
          .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
            value: bountyAmount,
          })
      )
        .to.emit(vulnerabilityRegistry, "VulnerabilitySubmitted")
        .withArgs(1, researcher.address, targetHash, severity, bountyAmount);

      expect(await vulnerabilityRegistry.getTotalVulnerabilities()).to.equal(1);
    });

    it("Should reject duplicate vulnerability targets", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      // Submit first vulnerability
      await vulnerabilityRegistry
        .connect(researcher)
        .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
          value: bountyAmount,
        });

      // Try to submit duplicate
      await expect(
        vulnerabilityRegistry
          .connect(researcher2)
          .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
            value: bountyAmount,
          })
      ).to.be.revertedWith("Duplicate vulnerability target");
    });

    it("Should reject invalid severity scores", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await expect(
        vulnerabilityRegistry
          .connect(researcher)
          .submitVulnerability(targetHash, 0, ipfsHash, toolOutputs, {
            value: bountyAmount,
          })
      ).to.be.revertedWith("Invalid severity score");

      await expect(
        vulnerabilityRegistry
          .connect(researcher)
          .submitVulnerability(targetHash, 11, ipfsHash, toolOutputs, {
            value: bountyAmount,
          })
      ).to.be.revertedWith("Invalid severity score");
    });

    it("Should require submission fee", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];

      await expect(
        vulnerabilityRegistry
          .connect(researcher)
          .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
            value: 0,
          })
      ).to.be.revertedWith("Submission fee required");
    });
  });

  describe("Vulnerability Validation", function () {
    let vulnId;

    beforeEach(async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml", "nikto-results.txt"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await vulnerabilityRegistry
        .connect(researcher)
        .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
          value: bountyAmount,
        });

      vulnId = 1;
    });

    it("Should allow validators to validate vulnerabilities", async function () {
      await expect(
        vulnerabilityRegistry.connect(validator1).validateVulnerability(vulnId, true)
      )
        .to.emit(vulnerabilityRegistry, "VulnerabilityValidated")
        .withArgs(vulnId, validator1.address, true);
    });

    it("Should prevent non-validators from validating", async function () {
      await expect(
        vulnerabilityRegistry.connect(researcher2).validateVulnerability(vulnId, true)
      ).to.be.revertedWith("Not authorized validator");
    });

    it("Should prevent double voting", async function () {
      await vulnerabilityRegistry.connect(validator1).validateVulnerability(vulnId, true);

      await expect(
        vulnerabilityRegistry.connect(validator1).validateVulnerability(vulnId, true)
      ).to.be.revertedWith("Already voted");
    });

    it("Should confirm vulnerability after threshold validations", async function () {
      // Need 3 validators for threshold (owner + validator1 + validator2)
      await vulnerabilityRegistry.connect(owner).validateVulnerability(vulnId, true);
      await vulnerabilityRegistry.connect(validator1).validateVulnerability(vulnId, true);

      await expect(
        vulnerabilityRegistry.connect(validator2).validateVulnerability(vulnId, true)
      ).to.emit(vulnerabilityRegistry, "VulnerabilityConfirmed");
    });
  });

  describe("Researcher Profile", function () {
    it("Should track researcher submissions", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await vulnerabilityRegistry
        .connect(researcher)
        .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
          value: bountyAmount,
        });

      const profile = await vulnerabilityRegistry.getResearcherProfile(researcher.address);
      expect(profile.totalSubmissions).to.equal(1);
      expect(profile.isActive).to.be.true;
    });

    it("Should update reputation after confirmation", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 9; // Critical severity
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await vulnerabilityRegistry
        .connect(researcher)
        .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
          value: bountyAmount,
        });

      // Validate with threshold
      await vulnerabilityRegistry.connect(owner).validateVulnerability(1, true);
      await vulnerabilityRegistry.connect(validator1).validateVulnerability(1, true);
      await vulnerabilityRegistry.connect(validator2).validateVulnerability(1, true);

      const profile = await vulnerabilityRegistry.getResearcherProfile(researcher.address);
      expect(profile.confirmedVulnerabilities).to.equal(1);
      expect(profile.reputationScore).to.equal(100); // Critical severity bonus
      expect(profile.totalEarnings).to.equal(bountyAmount);
    });
  });

  describe("Admin Functions", function () {
    it("Should allow owner to add validators", async function () {
      const newValidator = researcher2;

      await expect(vulnerabilityRegistry.addValidator(newValidator.address))
        .to.emit(vulnerabilityRegistry, "ValidatorAdded")
        .withArgs(newValidator.address);

      expect(await vulnerabilityRegistry.isValidator(newValidator.address)).to.be.true;
    });

    it("Should allow owner to remove validators", async function () {
      await vulnerabilityRegistry.removeValidator(validator1.address);
      expect(await vulnerabilityRegistry.isValidator(validator1.address)).to.be.false;
    });

    it("Should allow owner to pause contract", async function () {
      await vulnerabilityRegistry.pause();

      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await expect(
        vulnerabilityRegistry
          .connect(researcher)
          .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
            value: bountyAmount,
          })
      ).to.be.revertedWith("Pausable: paused");
    });

    it("Should prevent non-owners from admin functions", async function () {
      await expect(
        vulnerabilityRegistry.connect(researcher).addValidator(researcher2.address)
      ).to.be.revertedWith("Ownable: caller is not the owner");

      await expect(
        vulnerabilityRegistry.connect(researcher).pause()
      ).to.be.revertedWith("Ownable: caller is not the owner");
    });
  });

  describe("Integration with Escrow", function () {
    it("Should deposit bounty in escrow on submission", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      await vulnerabilityRegistry
        .connect(researcher)
        .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
          value: bountyAmount,
        });

      const escrowDetails = await bountyEscrow.getEscrowDetails(1);
      expect(escrowDetails.researcher).to.equal(researcher.address);
      expect(escrowDetails.amount).to.equal(bountyAmount);
    });
  });

  describe("Gas Optimization", function () {
    it("Should have reasonable gas costs for submission", async function () {
      const targetHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("example.com"));
      const severity = 8;
      const ipfsHash = "QmTestHash123";
      const toolOutputs = ["nmap-scan.xml"];
      const bountyAmount = ethers.utils.parseEther("0.1");

      const tx = await vulnerabilityRegistry
        .connect(researcher)
        .submitVulnerability(targetHash, severity, ipfsHash, toolOutputs, {
          value: bountyAmount,
        });

      const receipt = await tx.wait();
      console.log(`Gas used for vulnerability submission: ${receipt.gasUsed.toString()}`);

      // Should be under 500k gas for reasonable UX
      expect(receipt.gasUsed.toNumber()).to.be.lessThan(500000);
    });
  });
});