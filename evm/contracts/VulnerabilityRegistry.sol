// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./interfaces/IVulnerabilityRegistry.sol";
import "./interfaces/IBountyEscrow.sol";

/**
 * @title VulnerabilityRegistry
 * @notice Core contract for vulnerability submission and management
 * @dev Implements secure vulnerability storage with IPFS integration
 * @author Jon - ISSessions Cybersecurity Club
 */
contract VulnerabilityRegistry is ReentrancyGuard, Ownable, Pausable, IVulnerabilityRegistry {
    using Counters for Counters.Counter;

    Counters.Counter private _vulnerabilityIds;

    // State variables
    IBountyEscrow public bountyEscrow;
    uint256 public constant VALIDATION_THRESHOLD = 3; // Minimum validator consensus
    uint256 public constant DISCLOSURE_DELAY = 90 days; // Responsible disclosure period

    // Structs
    struct Vulnerability {
        uint256 id;
        address researcher;
        bytes32 targetHash; // Hashed target info for privacy
        uint8 severity; // CVSS score 1-10
        VulnStatus status;
        uint256 bountyAmount;
        uint256 submissionTime;
        uint256 disclosureTime;
        string ipfsHash; // Encrypted report on IPFS
        string[] toolOutputs; // Nmap, Nikto, Burp Suite results
        mapping(address => bool) validatorVotes;
        uint256 validationCount;
        bool bountyPaid;
    }

    struct ResearcherProfile {
        uint256 totalSubmissions;
        uint256 confirmedVulnerabilities;
        uint256 totalEarnings;
        uint256 reputationScore;
        bool isActive;
        uint256 lastSubmission;
    }

    // Mappings
    mapping(uint256 => Vulnerability) public vulnerabilities;
    mapping(address => ResearcherProfile) public researchers;
    mapping(address => bool) public validators;
    mapping(bytes32 => bool) public targetHashExists; // Prevent duplicates

    // Events
    event VulnerabilitySubmitted(
        uint256 indexed vulnId,
        address indexed researcher,
        bytes32 targetHash,
        uint8 severity,
        uint256 bountyAmount
    );

    event VulnerabilityValidated(
        uint256 indexed vulnId,
        address indexed validator,
        bool approved
    );

    event VulnerabilityConfirmed(
        uint256 indexed vulnId,
        uint256 bountyAmount
    );

    event VulnerabilityRejected(
        uint256 indexed vulnId,
        string reason
    );

    event BountyPaid(
        uint256 indexed vulnId,
        address indexed researcher,
        uint256 amount
    );

    event ValidatorAdded(address indexed validator);
    event ValidatorRemoved(address indexed validator);

    // Modifiers
    modifier onlyValidator() {
        require(validators[msg.sender], "Not authorized validator");
        _;
    }

    modifier validVulnerability(uint256 _vulnId) {
        require(_vulnId <= _vulnerabilityIds.current(), "Invalid vulnerability ID");
        _;
    }

    constructor() {
        _transferOwnership(msg.sender);
        validators[msg.sender] = true; // Owner is default validator
    }

    /**
     * @notice Submit a new vulnerability report
     * @param _targetHash Hashed target information
     * @param _severity CVSS severity score (1-10)
     * @param _ipfsHash IPFS hash of encrypted vulnerability report
     * @param _toolOutputs Array of penetration testing tool outputs
     */
    function submitVulnerability(
        bytes32 _targetHash,
        uint8 _severity,
        string calldata _ipfsHash,
        string[] calldata _toolOutputs
    ) external payable nonReentrant whenNotPaused {
        require(_severity >= 1 && _severity <= 10, "Invalid severity score");
        require(bytes(_ipfsHash).length > 0, "IPFS hash required");
        require(!targetHashExists[_targetHash], "Duplicate vulnerability target");
        require(msg.value > 0, "Submission fee required");

        _vulnerabilityIds.increment();
        uint256 newVulnId = _vulnerabilityIds.current();

        // Create vulnerability record
        Vulnerability storage vuln = vulnerabilities[newVulnId];
        vuln.id = newVulnId;
        vuln.researcher = msg.sender;
        vuln.targetHash = _targetHash;
        vuln.severity = _severity;
        vuln.status = VulnStatus.SUBMITTED;
        vuln.submissionTime = block.timestamp;
        vuln.ipfsHash = _ipfsHash;
        delete vuln.toolOutputs;
        for (uint i = 0; i < _toolOutputs.length; i++) {
            vuln.toolOutputs.push(_toolOutputs[i]);
        }
        vuln.bountyAmount = msg.value;

        // Mark target as submitted
        targetHashExists[_targetHash] = true;

        // Update researcher profile
        ResearcherProfile storage profile = researchers[msg.sender];
        profile.totalSubmissions++;
        profile.lastSubmission = block.timestamp;
        if (!profile.isActive) {
            profile.isActive = true;
        }

        // Transfer bounty to escrow
        if (address(bountyEscrow) != address(0)) {
            bountyEscrow.depositBounty{value: msg.value}(newVulnId, msg.sender);
        }

        emit VulnerabilitySubmitted(newVulnId, msg.sender, _targetHash, _severity, msg.value);
    }

    /**
     * @notice Validate a submitted vulnerability
     * @param _vulnId Vulnerability ID to validate
     * @param _approved Whether the vulnerability is valid
     */
    function validateVulnerability(
        uint256 _vulnId,
        bool _approved
    ) external onlyValidator validVulnerability(_vulnId) nonReentrant {
        Vulnerability storage vuln = vulnerabilities[_vulnId];
        require(vuln.status == VulnStatus.SUBMITTED, "Invalid status for validation");
        require(!vuln.validatorVotes[msg.sender], "Already voted");

        vuln.validatorVotes[msg.sender] = _approved;

        if (_approved) {
            vuln.validationCount++;
        }

        emit VulnerabilityValidated(_vulnId, msg.sender, _approved);

        // Check if validation threshold reached
        if (vuln.validationCount >= VALIDATION_THRESHOLD) {
            _confirmVulnerability(_vulnId);
        }
    }

    /**
     * @notice Internal function to confirm vulnerability and pay bounty
     */
    function _confirmVulnerability(uint256 _vulnId) internal {
        Vulnerability storage vuln = vulnerabilities[_vulnId];
        vuln.status = VulnStatus.CONFIRMED;
        vuln.disclosureTime = block.timestamp + DISCLOSURE_DELAY;

        // Update researcher reputation
        ResearcherProfile storage profile = researchers[vuln.researcher];
        profile.confirmedVulnerabilities++;
        profile.reputationScore += _calculateReputationIncrease(vuln.severity);

        // Trigger bounty payment through escrow
        if (address(bountyEscrow) != address(0) && !vuln.bountyPaid) {
            bountyEscrow.releaseBounty(_vulnId);
            vuln.bountyPaid = true;
            profile.totalEarnings += vuln.bountyAmount;

            emit BountyPaid(_vulnId, vuln.researcher, vuln.bountyAmount);
        }

        emit VulnerabilityConfirmed(_vulnId, vuln.bountyAmount);
    }

    /**
     * @notice Calculate reputation score increase based on severity
     */
    function _calculateReputationIncrease(uint8 _severity) internal pure returns (uint256) {
        if (_severity >= 9) return 100; // Critical
        if (_severity >= 7) return 75;  // High
        if (_severity >= 4) return 50;  // Medium
        return 25; // Low
    }

    /**
     * @notice Get vulnerability details (public after disclosure)
     */
    function getVulnerabilityDetails(uint256 _vulnId) 
        external 
        view 
        validVulnerability(_vulnId) 
        returns (
            address researcher,
            uint8 severity,
            VulnStatus status,
            uint256 submissionTime,
            uint256 disclosureTime,
            string memory ipfsHash,
            bool isDisclosed
        ) 
    {
        Vulnerability storage vuln = vulnerabilities[_vulnId];
        bool canDisclose = block.timestamp >= vuln.disclosureTime || vuln.status == VulnStatus.DISCLOSED;

        return (
            vuln.researcher,
            vuln.severity,
            vuln.status,
            vuln.submissionTime,
            vuln.disclosureTime,
            canDisclose ? vuln.ipfsHash : "",
            canDisclose
        );
    }

    /**
     * @notice Get researcher profile
     */
    function getResearcherProfile(address _researcher) 
        external 
        view 
        returns (ResearcherProfile memory) 
    {
        return researchers[_researcher];
    }

    /**
     * @notice Add validator (owner only)
     */
    function addValidator(address _validator) external onlyOwner {
        require(_validator != address(0), "Invalid validator address");
        validators[_validator] = true;
        emit ValidatorAdded(_validator);
    }

    /**
     * @notice Remove validator (owner only)
     */
    function removeValidator(address _validator) external onlyOwner {
        validators[_validator] = false;
        emit ValidatorRemoved(_validator);
    }

    /**
     * @notice Set bounty escrow contract
     */
    function setBountyEscrow(address _bountyEscrow) external onlyOwner {
        require(_bountyEscrow != address(0), "Invalid escrow address");
        bountyEscrow = IBountyEscrow(_bountyEscrow);
    }

    /**
     * @notice Emergency pause
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice Get total vulnerabilities count
     */
    function getTotalVulnerabilities() external view returns (uint256) {
        return _vulnerabilityIds.current();
    }

    /**
     * @notice Check if address is validator
     */
    function isValidator(address _address) external view returns (bool) {
        return validators[_address];
    }
}