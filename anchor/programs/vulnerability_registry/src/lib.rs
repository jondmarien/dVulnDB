use anchor_lang::prelude::*;

declare_id!("5mCoaixH9VVepuSsnhB769263Gg4RqBCEkkoJuHaH69K");

#[program]
pub mod vulnerability_registry {
    use super::*;

    /// Initialize the vulnerability registry state
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let state = &mut ctx.accounts.state;
        state.admin = ctx.accounts.admin.key();
        state.total_vulnerabilities = 0;
        state.validation_threshold = 3;
        state.disclosure_delay = 90 * 24 * 60 * 60; // 90 days in seconds
        state.paused = false;
        state.bump = *ctx.bumps.get("state").unwrap();
        Ok(())
    }

    /// Submit a new vulnerability report
    pub fn submit_vulnerability(
        ctx: Context<SubmitVulnerability>,
        target_hash: [u8; 32],
        severity: u8,
        ipfs_hash: String,
        tool_outputs: Vec<String>,
        bounty_amount: u64,
    ) -> Result<()> {
        let state = &mut ctx.accounts.state;
        require!(!state.paused, CustomError::ContractPaused);
        require!(severity >= 1 && severity <= 10, CustomError::InvalidSeverity);
        require!(!ipfs_hash.is_empty(), CustomError::EmptyIpfsHash);
        require!(bounty_amount > 0, CustomError::BountyRequired);

        // Check for duplicate target hash
        require!(
            ctx.accounts.target_check.data_is_empty(),
            CustomError::DuplicateTarget
        );

        let vuln_id = state.total_vulnerabilities + 1;
        state.total_vulnerabilities = vuln_id;

        let vulnerability = &mut ctx.accounts.vulnerability;
        vulnerability.id = vuln_id;
        vulnerability.researcher = ctx.accounts.researcher.key();
        vulnerability.target_hash = target_hash;
        vulnerability.severity = severity;
        vulnerability.status = VulnStatus::Submitted;
        vulnerability.bounty_amount = bounty_amount;
        vulnerability.submission_time = Clock::get()?.unix_timestamp;
        vulnerability.disclosure_time = 0;
        vulnerability.ipfs_hash = ipfs_hash;
        vulnerability.tool_outputs = tool_outputs;
        vulnerability.validation_count = 0;
        vulnerability.bounty_paid = false;
        vulnerability.bump = *ctx.bumps.get("vulnerability").unwrap();

        // Mark target hash as used
        let target_marker = &mut ctx.accounts.target_check;
        target_marker.target_hash = target_hash;
        target_marker.used = true;
        target_marker.bump = *ctx.bumps.get("target_check").unwrap();

        // Update researcher profile
        let profile = &mut ctx.accounts.researcher_profile;
        if profile.total_submissions == 0 {
            // Initialize new researcher
            profile.researcher = ctx.accounts.researcher.key();
            profile.is_active = true;
            profile.bump = *ctx.bumps.get("researcher_profile").unwrap();
        }
        profile.total_submissions += 1;
        profile.last_submission = Clock::get()?.unix_timestamp;

        // Transfer bounty to escrow if escrow program is set
        if state.bounty_escrow_program != Pubkey::default() {
            // Transfer SOL from researcher to this program account for escrow deposit
            anchor_lang::system_program::transfer(
                CpiContext::new(
                    ctx.accounts.system_program.to_account_info(),
                    anchor_lang::system_program::Transfer {
                        from: ctx.accounts.researcher.to_account_info(),
                        to: ctx.accounts.registry_vault.to_account_info(),
                    },
                ),
                bounty_amount,
            )?;
        }

        emit!(VulnerabilitySubmitted {
            vuln_id,
            researcher: ctx.accounts.researcher.key(),
            target_hash,
            severity,
            bounty_amount,
        });

        Ok(())
    }

    /// Validate a submitted vulnerability
    pub fn validate_vulnerability(
        ctx: Context<ValidateVulnerability>,
        vuln_id: u64,
        approved: bool,
    ) -> Result<()> {
        let state = &ctx.accounts.state;
        require!(!state.paused, CustomError::ContractPaused);

        let vulnerability = &mut ctx.accounts.vulnerability;
        require!(
            vulnerability.status == VulnStatus::Submitted,
            CustomError::InvalidStatusForValidation
        );

        // Check if validator already voted
        let validator_vote = &mut ctx.accounts.validator_vote;
        require!(
            validator_vote.data_is_empty(),
            CustomError::AlreadyVoted
        );

        // Record validator vote
        validator_vote.vuln_id = vuln_id;
        validator_vote.validator = ctx.accounts.validator.key();
        validator_vote.approved = approved;
        validator_vote.timestamp = Clock::get()?.unix_timestamp;
        validator_vote.bump = *ctx.bumps.get("validator_vote").unwrap();

        if approved {
            vulnerability.validation_count += 1;
        }

        emit!(VulnerabilityValidated {
            vuln_id,
            validator: ctx.accounts.validator.key(),
            approved,
        });

        // Check if validation threshold reached
        if vulnerability.validation_count >= state.validation_threshold {
            vulnerability.status = VulnStatus::Confirmed;
            vulnerability.disclosure_time = Clock::get()?.unix_timestamp + state.disclosure_delay;

            // Update researcher reputation
            let profile = &mut ctx.accounts.researcher_profile;
            profile.confirmed_vulnerabilities += 1;
            profile.reputation_score += calculate_reputation_increase(vulnerability.severity);

            // Trigger bounty payment through escrow if not already paid
            if !vulnerability.bounty_paid && vulnerability.bounty_amount > 0 {
                vulnerability.bounty_paid = true;
                profile.total_earnings += vulnerability.bounty_amount;

                emit!(BountyPaid {
                    vuln_id,
                    researcher: vulnerability.researcher,
                    amount: vulnerability.bounty_amount,
                });
            }

            emit!(VulnerabilityConfirmed {
                vuln_id,
                bounty_amount: vulnerability.bounty_amount,
            });
        }

        Ok(())
    }

    /// Add validator (admin only)
    pub fn add_validator(ctx: Context<UpdateValidator>) -> Result<()> {
        let validator_account = &mut ctx.accounts.validator_account;
        validator_account.validator = ctx.accounts.validator.key();
        validator_account.is_active = true;
        validator_account.added_at = Clock::get()?.unix_timestamp;
        validator_account.bump = *ctx.bumps.get("validator_account").unwrap();

        emit!(ValidatorAdded {
            validator: ctx.accounts.validator.key(),
        });

        Ok(())
    }

    /// Remove validator (admin only)
    pub fn remove_validator(ctx: Context<UpdateValidator>) -> Result<()> {
        let validator_account = &mut ctx.accounts.validator_account;
        validator_account.is_active = false;

        emit!(ValidatorRemoved {
            validator: ctx.accounts.validator.key(),
        });

        Ok(())
    }

    /// Set bounty escrow program (admin only)
    pub fn set_bounty_escrow(ctx: Context<SetBountyEscrow>, escrow_program: Pubkey) -> Result<()> {
        let state = &mut ctx.accounts.state;
        state.bounty_escrow_program = escrow_program;
        Ok(())
    }

    /// Pause/unpause contract (admin only)
    pub fn pause(ctx: Context<PauseContract>, pause: bool) -> Result<()> {
        let state = &mut ctx.accounts.state;
        state.paused = pause;
        Ok(())
    }

    /// Mark vulnerability as disclosed (after disclosure delay)
    pub fn disclose_vulnerability(ctx: Context<DiscloseVulnerability>) -> Result<()> {
        let vulnerability = &mut ctx.accounts.vulnerability;
        require!(
            vulnerability.status == VulnStatus::Confirmed,
            CustomError::InvalidStatusForDisclosure
        );

        let now = Clock::get()?.unix_timestamp;
        require!(
            now >= vulnerability.disclosure_time,
            CustomError::DisclosureDelayNotMet
        );

        vulnerability.status = VulnStatus::Disclosed;

        emit!(VulnerabilityDisclosed {
            vuln_id: vulnerability.id,
        });

        Ok(())
    }
}

// Program state account
#[account]
pub struct RegistryState {
    pub admin: Pubkey,
    pub total_vulnerabilities: u64,
    pub validation_threshold: u8,
    pub disclosure_delay: i64, // seconds
    pub bounty_escrow_program: Pubkey,
    pub paused: bool,
    pub bump: u8,
}

// Vulnerability record account
#[account]
pub struct Vulnerability {
    pub id: u64,
    pub researcher: Pubkey,
    pub target_hash: [u8; 32],
    pub severity: u8,
    pub status: VulnStatus,
    pub bounty_amount: u64,
    pub submission_time: i64,
    pub disclosure_time: i64,
    pub ipfs_hash: String,
    pub tool_outputs: Vec<String>,
    pub validation_count: u8,
    pub bounty_paid: bool,
    pub bump: u8,
}

// Researcher profile account
#[account]
pub struct ResearcherProfile {
    pub researcher: Pubkey,
    pub total_submissions: u64,
    pub confirmed_vulnerabilities: u64,
    pub total_earnings: u64,
    pub reputation_score: u64,
    pub is_active: bool,
    pub last_submission: i64,
    pub bump: u8,
}

// Target hash marker to prevent duplicates
#[account]
pub struct TargetHashMarker {
    pub target_hash: [u8; 32],
    pub used: bool,
    pub bump: u8,
}

// Validator account
#[account]
pub struct ValidatorAccount {
    pub validator: Pubkey,
    pub is_active: bool,
    pub added_at: i64,
    pub bump: u8,
}

// Validator vote record
#[account]
pub struct ValidatorVote {
    pub vuln_id: u64,
    pub validator: Pubkey,
    pub approved: bool,
    pub timestamp: i64,
    pub bump: u8,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum VulnStatus {
    Submitted,
    Confirmed,
    Rejected,
    Disclosed,
}

// Instruction contexts
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = admin,
        space = 8 + std::mem::size_of::<RegistryState>(),
        seeds = [b"registry_state"],
        bump
    )]
    pub state: Account<'info, RegistryState>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(target_hash: [u8; 32])]
pub struct SubmitVulnerability<'info> {
    #[account(mut, seeds = [b"registry_state"], bump = state.bump)]
    pub state: Account<'info, RegistryState>,
    #[account(
        init,
        payer = researcher,
        space = 8 + std::mem::size_of::<Vulnerability>() + 200 + 32 * 10, // Extra space for strings and vectors
        seeds = [b"vulnerability", &(state.total_vulnerabilities + 1).to_le_bytes()],
        bump
    )]
    pub vulnerability: Account<'info, Vulnerability>,
    #[account(
        init_if_needed,
        payer = researcher,
        space = 8 + std::mem::size_of::<ResearcherProfile>(),
        seeds = [b"researcher", researcher.key().as_ref()],
        bump
    )]
    pub researcher_profile: Account<'info, ResearcherProfile>,
    #[account(
        init,
        payer = researcher,
        space = 8 + std::mem::size_of::<TargetHashMarker>(),
        seeds = [b"target", &target_hash],
        bump
    )]
    pub target_check: Account<'info, TargetHashMarker>,
    #[account(
        mut,
        seeds = [b"registry_vault"],
        bump
    )]
    /// CHECK: This is a PDA used to hold funds for escrow deposits
    pub registry_vault: UncheckedAccount<'info>,
    #[account(mut)]
    pub researcher: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(vuln_id: u64)]
pub struct ValidateVulnerability<'info> {
    #[account(seeds = [b"registry_state"], bump = state.bump)]
    pub state: Account<'info, RegistryState>,
    #[account(
        mut,
        seeds = [b"vulnerability", &vuln_id.to_le_bytes()],
        bump = vulnerability.bump
    )]
    pub vulnerability: Account<'info, Vulnerability>,
    #[account(
        mut,
        seeds = [b"researcher", vulnerability.researcher.as_ref()],
        bump = researcher_profile.bump
    )]
    pub researcher_profile: Account<'info, ResearcherProfile>,
    #[account(
        seeds = [b"validator", validator.key().as_ref()],
        bump = validator_account.bump,
        constraint = validator_account.is_active @ CustomError::ValidatorNotActive
    )]
    pub validator_account: Account<'info, ValidatorAccount>,
    #[account(
        init,
        payer = validator,
        space = 8 + std::mem::size_of::<ValidatorVote>(),
        seeds = [b"vote", &vuln_id.to_le_bytes(), validator.key().as_ref()],
        bump
    )]
    pub validator_vote: Account<'info, ValidatorVote>,
    #[account(mut)]
    pub validator: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateValidator<'info> {
    #[account(seeds = [b"registry_state"], bump = state.bump, has_one = admin)]
    pub state: Account<'info, RegistryState>,
    #[account(
        init_if_needed,
        payer = admin,
        space = 8 + std::mem::size_of::<ValidatorAccount>(),
        seeds = [b"validator", validator.key().as_ref()],
        bump
    )]
    pub validator_account: Account<'info, ValidatorAccount>,
    /// CHECK: Validator pubkey is validated in the instruction
    pub validator: UncheckedAccount<'info>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SetBountyEscrow<'info> {
    #[account(mut, seeds = [b"registry_state"], bump = state.bump, has_one = admin)]
    pub state: Account<'info, RegistryState>,
    pub admin: Signer<'info>,
}

#[derive(Accounts)]
pub struct PauseContract<'info> {
    #[account(mut, seeds = [b"registry_state"], bump = state.bump, has_one = admin)]
    pub state: Account<'info, RegistryState>,
    pub admin: Signer<'info>,
}

#[derive(Accounts)]
pub struct DiscloseVulnerability<'info> {
    #[account(
        mut,
        seeds = [b"vulnerability", &vulnerability.id.to_le_bytes()],
        bump = vulnerability.bump
    )]
    pub vulnerability: Account<'info, Vulnerability>,
}

// Events
#[event]
pub struct VulnerabilitySubmitted {
    pub vuln_id: u64,
    pub researcher: Pubkey,
    pub target_hash: [u8; 32],
    pub severity: u8,
    pub bounty_amount: u64,
}

#[event]
pub struct VulnerabilityValidated {
    pub vuln_id: u64,
    pub validator: Pubkey,
    pub approved: bool,
}

#[event]
pub struct VulnerabilityConfirmed {
    pub vuln_id: u64,
    pub bounty_amount: u64,
}

#[event]
pub struct VulnerabilityDisclosed {
    pub vuln_id: u64,
}

#[event]
pub struct BountyPaid {
    pub vuln_id: u64,
    pub researcher: Pubkey,
    pub amount: u64,
}

#[event]
pub struct ValidatorAdded {
    pub validator: Pubkey,
}

#[event]
pub struct ValidatorRemoved {
    pub validator: Pubkey,
}

// Helper function
fn calculate_reputation_increase(severity: u8) -> u64 {
    match severity {
        9..=10 => 100, // Critical
        7..=8 => 75,   // High
        4..=6 => 50,   // Medium
        _ => 25,       // Low
    }
}

// Custom error codes
#[error_code]
pub enum CustomError {
    #[msg("Contract is paused")]
    ContractPaused,
    #[msg("Invalid severity score (must be 1-10)")]
    InvalidSeverity,
    #[msg("IPFS hash cannot be empty")]
    EmptyIpfsHash,
    #[msg("Bounty amount required")]
    BountyRequired,
    #[msg("Duplicate vulnerability target")]
    DuplicateTarget,
    #[msg("Invalid status for validation")]
    InvalidStatusForValidation,
    #[msg("Validator already voted")]
    AlreadyVoted,
    #[msg("Validator not active")]
    ValidatorNotActive,
    #[msg("Invalid status for disclosure")]
    InvalidStatusForDisclosure,
    #[msg("Disclosure delay not met")]
    DisclosureDelayNotMet,
}